import { Meta, Title, Subtitle, Description, Canvas, Primary, Controls, ArgsTable } from "@storybook/blocks";
import * as LayoutStories from "./Layout.stories";

<Meta of={LayoutStories} />

<Title>Layout Primitives</Title>

<Subtitle>Stack, Flex, Grid, Spacer를 사용해 간격과 정렬을 토큰 기반으로 구성합니다.</Subtitle>

<Description>
`@ara/react`의 레이아웃 프리미티브는 CSS 논리 프로퍼티와 반응형 속성을 우선으로 설계되었습니다. `gap`, `padding`, `wrap` 등 대부분의 간격은
토큰을 통해 일관되게 적용할 수 있으며, `Responsive` 타입(`{ base, sm, md, lg }`)으로 뷰포트에 따라 유연하게 변합니다. RTL 환경에서도 동일한
간격과 정렬을 유지합니다.

`orientation` prop에서 **horizontal / vertical**처럼 직관적인 이름을 선택하거나, CSS Flexbox 명칭을 그대로 쓸 때는 `direction`으로 `row` / `column`을 전달할
 수 있습니다. 두 prop은 동일하게 동작하며, 논리 축(inline/block) 기준으로 스타일을 계산합니다.

- orientation: `horizontal`(row), `horizontal-reverse`(row-reverse), `vertical`(column), `vertical-reverse`(column-reverse)
- direction: Flexbox 명칭 그대로(`row`, `column` 등). 예상한 방향과 다르면 페이지의 `writing-mode`(세로쓰기인지)나 RTL 여부를 확인해주세요.

### Row vs Column

- `row`: 가로(인라인) 축 정렬. LTR 기준 좌→우 순서로 나란히 배치됩니다.
- `column`: 세로(블록) 축 정렬. 위→아래로 쌓이며, 상단 영역이 첫 번째 아이템입니다.

Canvas 기본 예제의 `direction="column"` 상태는 세로 스택(위→아래)이며, `row`로 바꾸면 가로 스택(좌→우)으로 바뀝니다. 논리 축을 사용하므로 RTL에서는 `row`가 우→좌로, `column`은 동일하게 위→아래로 정렬됩니다.
</Description>

<Canvas of={LayoutStories.DirectionShowcase} />
<Canvas of={LayoutStories.LogicalAxisLegend} />

## Playground (Stack)

<Primary of={LayoutStories.Playground} />
<Controls of={LayoutStories.Playground} />

## Playground (Flex)

Flex에서 `orientation` 별칭을 그대로 사용할 수 있습니다. `inline`으로 컨테이너를 인라인 플렉스로 전환하고, `wrap`을 통해 여러 줄
로 넘길 수 있습니다.

<Canvas of={LayoutStories.FlexPlayground} />
<Controls of={LayoutStories.FlexPlayground} />

## Responsive

`direction`, `gap`, `align`, `justify`, `wrap`은 모두 반응형 객체를 받을 수 있습니다. 아래 예시는 모바일에서 세로 스택, 데스크톱에서 가로 스택으로
자동 전환합니다.

<Canvas of={LayoutStories.ResponsiveStack} />

## Patterns

툴바, 카드 그리드처럼 자주 쓰는 패턴을 Flex/Grid로 조합할 수 있습니다. 버튼·입력 등 실제 컴포넌트를 그대로 배치하면 실제 레이아웃에 가까운
간격을 검증할 수 있습니다.

<Canvas of={LayoutStories.FlexToolbar} />
<Canvas of={LayoutStories.GridCards} />

## Playground (Grid)

열·행 정의에 반응형 객체나 CSS 템플릿 문자열을 넣어 다양한 레이아웃을 실험할 수 있습니다. `areas` 배열로 네임드 영역도 지정할 수 있습니다.

<Canvas of={LayoutStories.GridPlayground} />
<Controls of={LayoutStories.GridPlayground} />

## Spacer 활용

컨테이너가 아닌 요소 사이에 간격만 필요할 때 `Spacer`를 사용합니다. `direction="inline"`으로 인라인 흐름에 맞춰 넣거나, `grow`/`shrink`로
플렉스 컨텍스트에서 남는 공간을 채우는 세퍼레이터로도 활용할 수 있습니다.

<Canvas of={LayoutStories.SpacerPatterns} />

## Playground (Spacer)

`size`를 토큰/픽셀 단위로 조정하고, 인라인/블록 방향과 `grow`/`shrink` 동작을 바로 확인할 수 있습니다.

<Canvas of={LayoutStories.SpacerPlayground} />
<Controls of={LayoutStories.SpacerPlayground} />

## Props

Stack·Flex·Grid·Spacer의 주요 props는 각 Playground의 Controls에서 바로 조정하거나 아래 표에서 확인할 수 있습니다.

<ArgsTable of={LayoutStories.Playground} />
